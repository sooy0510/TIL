# Flask

## 	1. Start Flask

### 1.0 가상환경 진입

- 우리는 앞으로 글로벌 환경이 아니라, 우리 프로젝트에 필요한 버전과 패키지만 사용하기 위해 가상환경에서 개발을 진행한다.

- 파이썬에 내장된 venv를 사용하자

  ```bash
  # 기본 사용법
  $ python -m venv 가상환경이름
  
  # 이렇게 만들어보자
  # 일단 지금은 어디서든 사용하기 편하게 루트 디렉토리에 가상환경을 생성한다.
  student@M15019 MINGW64 ~
  $ python -m venv venv
  
  ```

  - 자유롭게 이름 설정 가능하지만, 편하게 venv라고 통일하는 것을 권장(학습단계)

- 가상환경 실행 및 종료

  ```bash
  # 다른 경로에서도 편하게 가상환ㄱ여에 진입할 수 있다.
  student@M15019 MINGW64 ~/Desktop/TIL
  
  $ venv ~/venv/Scripts/activate	# for Windows
  $ venv ~/venv/bin/activate		# for Mac
  ```

- 가상환경 종료

  ```bash
  $ deactivate
  ```

- 이제 개발을 하기 전에 터미널에 (venv) 라는 가상환경 표시가 있는지 잘 확인하자!!

  ```bash
  (venv)
  student@M15019 MINGW64 ~/Desktop/TIL (master)
  ```

  

### 1.1 install

- 첫 시작은 무조건 공식문서[ http://flask.palletsprojects.com/en/1.1.x/ ]를 참고하자!

- 가상환경 먼저 실행시키고 Flask 설치

  ![1571793498441]( https://user-images.githubusercontent.com/31427258/67358576-df80b180-f59b-11e9-97c3-ae792e445f52.png )



- / : flask 실행시킬 때 기본 경로.?

![1571793676368]( https://user-images.githubusercontent.com/31427258/67358577-e0194800-f59b-11e9-94aa-b23c8d28e9c1.png )



### 1.2 개발용 서버 실행하기

- 일단 그냥 실행해보기

  ```bash
  $ FLASK_APP = hello.py flask run
  ```

  

- 여기서 생기는 두 가지 문제

  - 서버를 실행하는 명령어가 너무 길다
  - 코드 내용이 바뀌면 서버를 껐다 켜야된다

- 간단한 서버 실행 코드로 바꿔보기

  - hello.py -> app.py : flask는 기본적으로 폴더에서 app.py를 실행하려고 한다

  - 실제 개발단계에서도 이름을 app.py로 하는 것을 권장

  - 코드 추가하기

    ```python
    # app.py
    
    ...
    
    # end of file !!!!!!
    # debug 모드를 활성화해서 서버 새로고침을 생략한다
    if __name__ == '__main__':
      app.run(debug=True)
    ```

  - 명령어 실행

    ```bash
    $ python app.py
    ```

    



### 1.3 간단한 페이지 렌더링하기

> 단순한 문자열 리턴, HTML 태그 리턴이 모두 가능하다

- <strong>문자열</strong> 리턴

  ```python
  @app.route('/sooy')
  def sooy():
    return '수연이다!'
  ```

- <strong>HTML 요소</strong> 사용해서 리턴 

  ```python
  @app.route('/html')
  def html():
    return '<h1>태그 사용가능</h1>'
  
  @app.route('/html_multiline')
  def html_multiline():
    return """
    <ol>
      <li>하이하이</li>
    </ol>
    """
  ```

  



### 1.4 동적 라우팅(Variable Routing)

> 사용자가 URL을 통해 입력한 값을 받아서 사용할 수 있다

```python
# 동적 라우팅(Variable Routing)
@app.route('/greeting/<string:name>')
def greeting(name):
  return f'반가워요, {name}'
```



### 1.5 Render Template

> 템플릿을 미리 만들어두고 사용자에게 보여줄 수 있다

- flask에서 제공하는 render_template 모듈을 불러온다.

  ```python
  from flask import Flask, render_template
  ```

- templates 폴더를 생성한다.

  - 플라스크는 render_template 메서드를 사용할 때 기본적으로 루트 디렉토리에 있는 templates라는 폴더를 탐색해서 html 파일을 찾는다.

    ※  뒤에 s 빼먹으면 jina2 관련 에러를 내니 조심할 것!

![1571795541586]( https://user-images.githubusercontent.com/31427258/67358579-e0194800-f59b-11e9-81ae-5f32bf56363b.png )



- 사용해보자

  ```python
  @app.route('/')
  def hello():
    return render_template('index.html')
  ```



- **render_template + parameters** : 사용자에게 숫자값을 받아서, 세제곱한 결과를 돌려주기

  - app.py

    ```python
    @app.route('/cube/<int:num>')
    def cube(num):
      result = num**3
      #사용자로부터 값을 넘겨받고 rendering하고자 하는 html에서 지정한 이름으로 사용가능
      return render_template('cube.html', num=num, result=result)
    ```

  - /templates/cube.html

    ```html
    ...
    <body>
       
      <h1>{{num}}을 세제곱한 결과 : {{result}}</h1>
    </body>
    ...
    ```

  - 실행화면

    ![1571795822201]( https://user-images.githubusercontent.com/31427258/67358580-e0194800-f59b-11e9-998b-e95c85e6a907.png )



### 1.6 Jinja2 템플릿 사용하기

- 조건문

  - app.py

    ```python
    @app.route('/greeting/<string:name>')
    def greeting(name):
      #사용자로부터 이름을 넘겨받고 rendering하고자 하는 html에서 지정한 이름으로 사용가능
      return render_template('greeting.html', html_name=name)
    ```

  - /templates/greeting.html

    ```html
    <body>
      <h1>당신의 이름은 {{html_name}} 입니다</h1>
      {% if html_name == '수연' %}
        <p>어서오세요, sooy님~~</p>
      {% else %}
        <p>누구세요..?</p>
      {% endif %}
    </body>
    ```



- 반복문

  - app.py

    ```python
    @app.route('/movies')
    def movies():
      movie_list = ['82년생김지영','조커','엔드게임','궁예']
      return render_template('movies.html', movies=movie_list)
    ```

  - /templates/movies.html

    ```html
    <body>
      <h1>영화 목록</h1>
      <ul>
        {% for movie in movies %}
        <li>{{movie}}</li>
        {% endfor %}
      </ul>
    </body>
    ```

    





## 2. 응답-요청(Request-Response)

### 2.1 Ping Pong

- Ping : 사용자가 일정한 주소로 요청을 보내면, 사용자가 어떠한 값을 입력할 수 있는 Form이 담겨있는 페이지를 보여준다.
- Pong : 사용자로부터 Form 입력 데이터를 받아서, 데이터를 가공해서 다시 보여준다. 

```python
# ping : 사용자로부터 입력을 받을 Form 페이지를 넘겨준다.
@app.route('/ping')
def ping():
  return render_template('ping.html')

# pong : 사용자로부터 Form 데이터를 전달받아서 가공한다.
@app.route('/pong')
def pong():
  user_name = request.args.get('user_name')
  return render_template('pong.html', user_name = user_name)
```

```html
<!-- ping.html -->
<body>
  <!-- GET : 서버측에 어떤 데이터를 달라고 요청 -->
  <form action="/pong" method="GET">
    이름 : <input type="text" name="user_name"><br>
    <input type="submit" value="제출">
  </form>
</body>

<!-- pong.html -->
<body>
  <h2>{{user_name}} 님 안녕하세요! 데이터가 저희 서버로 들어왔어요.</h2>
</body>
```



### 2.2 Fake Naver & Fake Google

> 위 ping-pong 구조에서 온전히 우리 웹 서비스 내에서 요청과 응답 프로세스를 구현했다. 하지만 사용자로부터 요청만 받은 뒤, 데이터를 처리해서 돌려주는 응답 프로세스를 다른 서버 측에 넘겨줄 수도 있다.

- Fake Naver

  ```python
  @app.route('/naver')
  def naver():
    return render_template('naver.html')
  ```

  ```html
  <body>
    <form action="https://search.naver.com/search.naver">
      <!-- naver에 넘겨줄 데이터를 담을 name은 query말고 다른 이름으로 지정해도 상관없다 -->
      <input type="text" name="query">
      <input type="submit">
    </form>
  </body>
  ```

  

