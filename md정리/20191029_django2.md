# Django2

## 1. HTML Form Tag

- static web vs dynamic web
  - **static web** : 단순히 html 페이지 여러개로 구성되어있는 사이트
  - **dynamic web** : 데이터베이스에 변동을 주어서 데이터베이스에 따라 웹 사이트의 내용이 바뀌는 웹 서비스
- Form을 통해서 사용자로부터 정보를 받거나 정보를 가공하거나 하는 로직을 구현했었는데, 결국 dynamic web을 구현하기 위해서는 Form을 통해서 정보를 요청하는 절차가 반드시 필요하다
- **`<form></form>`**
  - 사용자로부터 제공받은 데이터를 서버 측에 전송해주는 역할
  - 사용자가 여러 정보를 입력할 수 있는 수단을 제공 => input 태그를 통해!
    - `<form action="/new/">` : 어디로 보낼 것인지 서버측 경로를 지정
    - `<form action="" method="GET">` : 요청 방식을 무엇으로 할 것인지 지정
- **`<input>`**
  - Form 태그 안에서 가장 중요한 태그! 사용자로부터 어떠한 정보를 입력받는 태그
  - `<input type="">` : 사용자가 입력할 데이터의 종류 지정
  - `<input type="" name="">` : 서버측에서 사용자가 입력한 값을 가져올 이름으로 사용 





## 1. HTML Form - GET 요청

#### 2.1 기본 개념

- 요청의 종류 중 GET 요청은 서버로부터 정보를 조회하는데 사용한다. 데이터를 서버로 전송할 때 쿼리스트링을 통해 전송한다.

- 서버의 데이터(리소스)를 변경시키지 않는 요청이고, HTML 파일을 조회할 때 사용한다. 우리는 서버에 GET 요청을 하면, HTML 문서 한 장을 받는다.

- throw & catch

  ```python
  # views.py
  
  # 정보를 던져줄 페이지
  def throw(request):
    return render(request, 'throw.html')
  
  # 사용자로부터 정보를 받아서 다시 던져줄 페이지
  def catch(request):
    # flask : request.args.get
    message = request.GET.get('message')
    context = {'message' : message}
    return render(request,'catch.html',context)
  ```

  ```html
  <!-- throw.html -->
  
  <form action="/catch/" method="GET">
    <input type="text" name="message">
    <input type="submit" value="던져!">
  </form>
  ```

  ```html
  <!-- catch.html -->
  
  <h1>받은 정보의 내용은, {{ message }}</h1>
  ```

  



#### 2.2 실습

- ASCII ART

  - requests 설치

  ```python
  # [실습] 아스키 아트 API를 통한 요청-응답 실습
  # 사용자로부터 텍스트 입력받는 페이지
  def art(request):
    return render(request,'art.html')
  
  # 텍스트 받아서 아스키 아트로 보여주는 페이지
  def result(request):
    # 1. 사용자가 입력한 Form 데이터를 가져온다.
    # request.GET : 사용자가 input을 통해 넘겨준 데이터가 dictionary 형태로 들어옴
    word = request.GET.get('word')
  
    # 2. ARTII API로 요청을 보내서, 응답 결과를 변수에 담는다. (폰트 정보들)
    fonts = requests.get('http://artii.herokuapp.com/fonts_list').text
  
    # 3. 가져온 폰트들을 리스트 형태로 담는다.
    fonts = fonts.split('\n')
  
    # 4. 폰트 하나를 랜덤으로 선택한다.
    font = random.choice(fonts)
  
    # 5. 사용자가 입력한 단어와 랜덤으로 선택한 폰트 정보를 담아서 API에게 요청한다.
    result = requests.get(
      f'http://artii.herokuapp.com/make?text={word}&font={font}'
    ).text
  
    # 6. 최종 결과물을 사용자에게 리턴한다.
    context = {'result': result}
  
    return render(request, 'result.html', context)
  
  ```

  ```html
  <!-- art.html -->
  
  <form action="/result/" method="GET">
    <input type="text" name="word" placeholder="변환할 문자열을 입력하세요">
    <input type="submit" value="뾰로롱☆">
  </form>
  ```

  ```html
  <!-- result.html -->
  
  <!-- 원본 그대로 나오게 하려면 p태그 -->
  <pre>
    {{ result }}
  </pre>
  ```

- 실행

  > ![1572322140537](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1572322140537.png)

  > ![1572322178825](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1572322178825.png)



## 3. HTML Form - POST 요청

- CRUD
  - Create : 생성
  - Read : 조회
  - Update : 수정
  - Delete : 삭제



#### 3.1 기본 개념

- POST 요청은 GET 요청처럼 쿼리스트링에 데이터가 노출되는 것이 아니라, **HTTP Body에 담겨서 전송**된다

  - GET 요청 -> Read
  - POST 요청 ->  Create, Update, Delete

- POST 요청은 데이터(리소스)를 수정/삭제시키는 로직이기 때문에, 똑같은 요청을 여러번 시도하게 되면 서버에서 응답하는 결과가 다를 수 있다

- 원칙적으로 POST 요청을 보냈는데 HTML 파일을 그려주는(render) 응답은 해서는 안된다. **HTML 파일을 그려주는 응답은 GET 요청에서만 사용**한다.

  - ex) 사용자가 로그인을 하는 로직은 POST 요청을 통해서 이루어진다. 로직 마지막에 어떤 정보를 변수로 넘겨서 HTML파일을 넘겨주는 로직을 구현하는게 아니라, 로그인이 끝나면 메인 페이지('/') 등으로 redirect 시켜주는 로직을 구현해야 한다,

- **{% csrf_token %}**

  - **CSRF 공격**을 막기위한 최소한의 신원 확인 장치

  - 장고 내부적으로 CSRF 공격을 막기 위한 미들웨어가 기본적으로 적용되어 있다

    ```python
    # settings.py
    
    MIDDLEWARE = [
        ...
        'django.middleware.csrf.CsrfViewMiddleware',
    	...
    ]
    ```

    - 얘가 존재하기 때문에 , Form 에서 POST 요청을 할 때 `{% csrf_token %}` 을 넣지 않으면 `403 forbidden` 에러를 뿜는다. 403 에러는 서버에는 정상적으로 접근을 하였으나, 권한이 없어서 접근하지 못하는 에러이다.

      > ![1572323573244](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1572323573244.png)

    

    - `settings.py`에서 해당코드를 삭제하면 Form에 `{% csrf_token %}`가 없어도 정상적으로 접근하고 결과를 보여준다

    - **GET 요청**은 "야, HTML 파일 하나 내놔!"라고 하는 단순한 정보 조회 로직이지만, **POST 요청**은 서버측 DB(리소스)에 변경을 요청하는 것이기 때문에 신원을 확인하는 절차가 없으면 임의의 공격을 통해 서버가 해킹당하게 된다

    - `{% csrf_token %}` 을 코드에 삽입하면, 실제 Form 태그를 개발자 도구로 찍어보면 `hidden type`의 input 태그가 생기고 그 안에 암호화된 hash 값이 함께 전송되는 것을 확인할 수 있다.

      > ![1572323935274](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1572323935274.png)